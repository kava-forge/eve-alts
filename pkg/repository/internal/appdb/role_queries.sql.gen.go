// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: role_queries.sql

package appdb

import (
	"context"
	"strings"
)

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE "id" = ?
`

func (q *Queries) DeleteRole(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteRole, id)
	return err
}

const deleteRoleTags = `-- name: DeleteRoleTags :exec
DELETE FROM role_tags
WHERE 
    "role_id" = ?
    AND "tag_id" IN (/*SLICE:tag_ids*/?)
`

type DeleteRoleTagsParams struct {
	RoleID int64
	TagIds []int64
}

func (q *Queries) DeleteRoleTags(ctx context.Context, db DBTX, arg DeleteRoleTagsParams) error {
	query := deleteRoleTags
	var queryParams []interface{}
	queryParams = append(queryParams, arg.RoleID)
	if len(arg.TagIds) > 0 {
		for _, v := range arg.TagIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", strings.Repeat(",?", len(arg.TagIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:tag_ids*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const getAllRoleTags = `-- name: GetAllRoleTags :many
SELECT tags.id, tags.name, tags.color_r, tags.color_g, tags.color_b, tags.color_a
FROM tags
JOIN role_tags ON tags."id" = role_tags."tag_id"
WHERE role_tags."role_id" = ?
ORDER BY tags."name"
`

func (q *Queries) GetAllRoleTags(ctx context.Context, db DBTX, roleID int64) ([]Tag, error) {
	rows, err := db.QueryContext(ctx, getAllRoleTags, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ColorR,
			&i.ColorG,
			&i.ColorB,
			&i.ColorA,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRoles = `-- name: GetAllRoles :many
SELECT 
    id, name, label, operator, color_r, color_g, color_b, color_a
FROM roles
ORDER BY "name"
`

func (q *Queries) GetAllRoles(ctx context.Context, db DBTX) ([]Role, error) {
	rows, err := db.QueryContext(ctx, getAllRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Label,
			&i.Operator,
			&i.ColorR,
			&i.ColorG,
			&i.ColorB,
			&i.ColorA,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRole = `-- name: InsertRole :one

INSERT INTO roles ("name", "label", "operator", "color_r", "color_g", "color_b", "color_a")
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, label, operator, color_r, color_g, color_b, color_a
`

type InsertRoleParams struct {
	Name     string
	Label    string
	Operator string
	ColorR   int64
	ColorG   int64
	ColorB   int64
	ColorA   int64
}

func (q *Queries) InsertRole(ctx context.Context, db DBTX, arg InsertRoleParams) (Role, error) {
	row := db.QueryRowContext(ctx, insertRole,
		arg.Name,
		arg.Label,
		arg.Operator,
		arg.ColorR,
		arg.ColorG,
		arg.ColorB,
		arg.ColorA,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Label,
		&i.Operator,
		&i.ColorR,
		&i.ColorG,
		&i.ColorB,
		&i.ColorA,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :exec
UPDATE roles
SET
    "name" = ?,
    "label" = ?,
    "operator" = ?,
    "color_r" = ?,
    "color_g" = ?,
    "color_b" = ?,
    "color_a" = ?
WHERE "id" = ?
`

type UpdateRoleParams struct {
	Name     string
	Label    string
	Operator string
	ColorR   int64
	ColorG   int64
	ColorB   int64
	ColorA   int64
	ID       int64
}

func (q *Queries) UpdateRole(ctx context.Context, db DBTX, arg UpdateRoleParams) error {
	_, err := db.ExecContext(ctx, updateRole,
		arg.Name,
		arg.Label,
		arg.Operator,
		arg.ColorR,
		arg.ColorG,
		arg.ColorB,
		arg.ColorA,
		arg.ID,
	)
	return err
}

const upsertRoleTag = `-- name: UpsertRoleTag :one
INSERT INTO role_tags ("role_id", "tag_id")
VALUES (?, ?)
ON CONFLICT ("role_id", "tag_id") DO NOTHING
RETURNING role_id, tag_id
`

type UpsertRoleTagParams struct {
	RoleID int64
	TagID  int64
}

func (q *Queries) UpsertRoleTag(ctx context.Context, db DBTX, arg UpsertRoleTagParams) (RoleTag, error) {
	row := db.QueryRowContext(ctx, upsertRoleTag, arg.RoleID, arg.TagID)
	var i RoleTag
	err := row.Scan(&i.RoleID, &i.TagID)
	return i, err
}
