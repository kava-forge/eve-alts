// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: character_queries.sql

package appdb

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE "id" = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const deleteCharacterSkills = `-- name: DeleteCharacterSkills :exec
DELETE FROM character_skills
WHERE 
    "character_id" = ?
    AND "skill_id" IN (/*SLICE:skill_ids*/?)
`

type DeleteCharacterSkillsParams struct {
	CharacterID int64
	SkillIds    []int64
}

func (q *Queries) DeleteCharacterSkills(ctx context.Context, db DBTX, arg DeleteCharacterSkillsParams) error {
	query := deleteCharacterSkills
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.SkillIds) > 0 {
		for _, v := range arg.SkillIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", strings.Repeat(",?", len(arg.SkillIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const getAllCharacterSkills = `-- name: GetAllCharacterSkills :many
SELECT character_id, skill_id, skill_level
FROM character_skills
WHERE "character_id" = ?
ORDER BY "skill_id"
`

func (q *Queries) GetAllCharacterSkills(ctx context.Context, db DBTX, characterID int64) ([]CharacterSkill, error) {
	rows, err := db.QueryContext(ctx, getAllCharacterSkills, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CharacterSkill
	for rows.Next() {
		var i CharacterSkill
		if err := rows.Scan(&i.CharacterID, &i.SkillID, &i.SkillLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCharacters = `-- name: GetAllCharacters :many
SELECT 
    characters.id, characters.name, characters.picture, characters.corporation_id,
    corporations.id, corporations.alliance_id, corporations.name, corporations.ticker, corporations.picture,
    alliances.id, alliances.name, alliances.ticker, alliances.picture
FROM characters
INNER JOIN corporations ON characters."corporation_id" = corporations."id"
LEFT JOIN alliances ON corporations."alliance_id" = alliances."id"
`

type GetAllCharactersRow struct {
	Character   Character
	Corporation Corporation
	Alliance    Alliance
}

func (q *Queries) GetAllCharacters(ctx context.Context, db DBTX) ([]GetAllCharactersRow, error) {
	rows, err := db.QueryContext(ctx, getAllCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCharactersRow
	for rows.Next() {
		var i GetAllCharactersRow
		if err := rows.Scan(
			&i.Character.ID,
			&i.Character.Name,
			&i.Character.Picture,
			&i.Character.CorporationID,
			&i.Corporation.ID,
			&i.Corporation.AllianceID,
			&i.Corporation.Name,
			&i.Corporation.Ticker,
			&i.Corporation.Picture,
			&i.Alliance.ID,
			&i.Alliance.Name,
			&i.Alliance.Ticker,
			&i.Alliance.Picture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenForCharacter = `-- name: GetTokenForCharacter :one
SELECT id, character_id, access_token, refresh_token, token_type, expiration 
FROM tokens
WHERE "character_id" = ?
LIMIT 1
`

func (q *Queries) GetTokenForCharacter(ctx context.Context, db DBTX, characterID int64) (Token, error) {
	row := db.QueryRowContext(ctx, getTokenForCharacter, characterID)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenType,
		&i.Expiration,
	)
	return i, err
}

const upsertAlliance = `-- name: UpsertAlliance :one
INSERT INTO alliances ("id", "name", "ticker", "picture")
VALUES (?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "ticker" = excluded.ticker
RETURNING id, name, ticker, picture
`

type UpsertAllianceParams struct {
	ID      sql.NullInt64
	Name    sql.NullString
	Ticker  sql.NullString
	Picture sql.NullString
}

func (q *Queries) UpsertAlliance(ctx context.Context, db DBTX, arg UpsertAllianceParams) (Alliance, error) {
	row := db.QueryRowContext(ctx, upsertAlliance,
		arg.ID,
		arg.Name,
		arg.Ticker,
		arg.Picture,
	)
	var i Alliance
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ticker,
		&i.Picture,
	)
	return i, err
}

const upsertCharacter = `-- name: UpsertCharacter :one
INSERT INTO characters ("id", "name", "picture", "corporation_id")
VALUES (?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "corporation_id" = excluded.corporation_id
RETURNING id, name, picture, corporation_id
`

type UpsertCharacterParams struct {
	ID            int64
	Name          string
	Picture       string
	CorporationID int64
}

func (q *Queries) UpsertCharacter(ctx context.Context, db DBTX, arg UpsertCharacterParams) (Character, error) {
	row := db.QueryRowContext(ctx, upsertCharacter,
		arg.ID,
		arg.Name,
		arg.Picture,
		arg.CorporationID,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Picture,
		&i.CorporationID,
	)
	return i, err
}

const upsertCharacterSkill = `-- name: UpsertCharacterSkill :one
INSERT INTO character_skills ("character_id", "skill_id", "skill_level")
VALUES (?, ?, ?)
ON CONFLICT ("character_id", "skill_id") DO UPDATE
SET
    "skill_level" = excluded.skill_level
RETURNING character_id, skill_id, skill_level
`

type UpsertCharacterSkillParams struct {
	CharacterID int64
	SkillID     int64
	SkillLevel  int64
}

func (q *Queries) UpsertCharacterSkill(ctx context.Context, db DBTX, arg UpsertCharacterSkillParams) (CharacterSkill, error) {
	row := db.QueryRowContext(ctx, upsertCharacterSkill, arg.CharacterID, arg.SkillID, arg.SkillLevel)
	var i CharacterSkill
	err := row.Scan(&i.CharacterID, &i.SkillID, &i.SkillLevel)
	return i, err
}

const upsertCorporation = `-- name: UpsertCorporation :one
INSERT INTO corporations ("id", "name", "ticker", "alliance_id", "picture")
VALUES (?, ?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "alliance_id" = excluded.alliance_id,
    "ticker" = excluded.ticker
RETURNING id, alliance_id, name, ticker, picture
`

type UpsertCorporationParams struct {
	ID         int64
	Name       string
	Ticker     string
	AllianceID sql.NullInt64
	Picture    string
}

func (q *Queries) UpsertCorporation(ctx context.Context, db DBTX, arg UpsertCorporationParams) (Corporation, error) {
	row := db.QueryRowContext(ctx, upsertCorporation,
		arg.ID,
		arg.Name,
		arg.Ticker,
		arg.AllianceID,
		arg.Picture,
	)
	var i Corporation
	err := row.Scan(
		&i.ID,
		&i.AllianceID,
		&i.Name,
		&i.Ticker,
		&i.Picture,
	)
	return i, err
}

const upsertToken = `-- name: UpsertToken :one

INSERT INTO tokens ("character_id", "access_token", "refresh_token", "token_type", "expiration")
VALUES (?, ?, ?, ?, ?)
ON CONFLICT ("character_id") DO UPDATE
SET
    "access_token" = excluded.access_token,
    "refresh_token" = excluded.refresh_token,
    "token_type" = excluded.token_type,
    "expiration" = excluded.expiration
RETURNING id, character_id, access_token, refresh_token, token_type, expiration
`

type UpsertTokenParams struct {
	CharacterID  int64
	AccessToken  string
	RefreshToken string
	TokenType    string
	Expiration   time.Time
}

func (q *Queries) UpsertToken(ctx context.Context, db DBTX, arg UpsertTokenParams) (Token, error) {
	row := db.QueryRowContext(ctx, upsertToken,
		arg.CharacterID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenType,
		arg.Expiration,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenType,
		&i.Expiration,
	)
	return i, err
}
