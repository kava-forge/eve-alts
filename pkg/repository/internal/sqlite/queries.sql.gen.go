// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package sqlite

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters
WHERE "id" = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const deleteCharacterSkills = `-- name: DeleteCharacterSkills :exec
DELETE FROM character_skills
WHERE 
    "character_id" = ?
    AND "skill_id" IN (/*SLICE:skill_ids*/?)
`

type DeleteCharacterSkillsParams struct {
	CharacterID int64
	SkillIds    []int64
}

func (q *Queries) DeleteCharacterSkills(ctx context.Context, db DBTX, arg DeleteCharacterSkillsParams) error {
	query := deleteCharacterSkills
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CharacterID)
	if len(arg.SkillIds) > 0 {
		for _, v := range arg.SkillIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", strings.Repeat(",?", len(arg.SkillIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE "id" = ?
`

func (q *Queries) DeleteTag(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteTag, id)
	return err
}

const deleteTagSkills = `-- name: DeleteTagSkills :exec
DELETE FROM tag_skills
WHERE 
    "tag_id" = ?
    AND "skill_id" IN (/*SLICE:skill_ids*/?)
`

type DeleteTagSkillsParams struct {
	TagID    int64
	SkillIds []int64
}

func (q *Queries) DeleteTagSkills(ctx context.Context, db DBTX, arg DeleteTagSkillsParams) error {
	query := deleteTagSkills
	var queryParams []interface{}
	queryParams = append(queryParams, arg.TagID)
	if len(arg.SkillIds) > 0 {
		for _, v := range arg.SkillIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", strings.Repeat(",?", len(arg.SkillIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:skill_ids*/?", "NULL", 1)
	}
	_, err := db.ExecContext(ctx, query, queryParams...)
	return err
}

const getAllCharacterSkills = `-- name: GetAllCharacterSkills :many
SELECT character_id, skill_id, skill_level
FROM character_skills
WHERE "character_id" = ?
ORDER BY "skill_id"
`

func (q *Queries) GetAllCharacterSkills(ctx context.Context, db DBTX, characterID int64) ([]CharacterSkill, error) {
	rows, err := db.QueryContext(ctx, getAllCharacterSkills, characterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CharacterSkill
	for rows.Next() {
		var i CharacterSkill
		if err := rows.Scan(&i.CharacterID, &i.SkillID, &i.SkillLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCharacters = `-- name: GetAllCharacters :many
SELECT 
    characters.id, characters.name, characters.picture, characters.corporation_id,
    corporations.id, corporations.alliance_id, corporations.name, corporations.ticker, corporations.picture,
    alliances.id, alliances.name, alliances.ticker, alliances.picture
FROM characters
INNER JOIN corporations ON characters."corporation_id" = corporations."id"
LEFT JOIN alliances ON corporations."alliance_id" = alliances."id"
`

type GetAllCharactersRow struct {
	Character   Character
	Corporation Corporation
	Alliance    Alliance
}

func (q *Queries) GetAllCharacters(ctx context.Context, db DBTX) ([]GetAllCharactersRow, error) {
	rows, err := db.QueryContext(ctx, getAllCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCharactersRow
	for rows.Next() {
		var i GetAllCharactersRow
		if err := rows.Scan(
			&i.Character.ID,
			&i.Character.Name,
			&i.Character.Picture,
			&i.Character.CorporationID,
			&i.Corporation.ID,
			&i.Corporation.AllianceID,
			&i.Corporation.Name,
			&i.Corporation.Ticker,
			&i.Corporation.Picture,
			&i.Alliance.ID,
			&i.Alliance.Name,
			&i.Alliance.Ticker,
			&i.Alliance.Picture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTagSkills = `-- name: GetAllTagSkills :many
SELECT tag_id, skill_id, skill_level
FROM tag_skills
WHERE "tag_id" = ?
ORDER BY "skill_id"
`

func (q *Queries) GetAllTagSkills(ctx context.Context, db DBTX, tagID int64) ([]TagSkill, error) {
	rows, err := db.QueryContext(ctx, getAllTagSkills, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagSkill
	for rows.Next() {
		var i TagSkill
		if err := rows.Scan(&i.TagID, &i.SkillID, &i.SkillLevel); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTags = `-- name: GetAllTags :many
SELECT 
    id, name, color_r, color_g, color_b
FROM tags
ORDER BY "name"
`

func (q *Queries) GetAllTags(ctx context.Context, db DBTX) ([]Tag, error) {
	rows, err := db.QueryContext(ctx, getAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ColorR,
			&i.ColorG,
			&i.ColorB,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenForCharacter = `-- name: GetTokenForCharacter :one
SELECT id, character_id, access_token, refresh_token, token_type, expiration 
FROM tokens
WHERE "character_id" = ?
LIMIT 1
`

func (q *Queries) GetTokenForCharacter(ctx context.Context, db DBTX, characterID int64) (Token, error) {
	row := db.QueryRowContext(ctx, getTokenForCharacter, characterID)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenType,
		&i.Expiration,
	)
	return i, err
}

const insertTag = `-- name: InsertTag :one

INSERT INTO tags ("name", "color_r", "color_g", "color_b")
VALUES (?, ?, ?, ?)
RETURNING id, name, color_r, color_g, color_b
`

type InsertTagParams struct {
	Name   string
	ColorR int64
	ColorG int64
	ColorB int64
}

func (q *Queries) InsertTag(ctx context.Context, db DBTX, arg InsertTagParams) (Tag, error) {
	row := db.QueryRowContext(ctx, insertTag,
		arg.Name,
		arg.ColorR,
		arg.ColorG,
		arg.ColorB,
	)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ColorR,
		&i.ColorG,
		&i.ColorB,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tags
SET
    "name" = ?,
    "color_r" = ?,
    "color_g" = ?,
    "color_b" = ?
WHERE "id" = ?
`

type UpdateTagParams struct {
	Name   string
	ColorR int64
	ColorG int64
	ColorB int64
	ID     int64
}

func (q *Queries) UpdateTag(ctx context.Context, db DBTX, arg UpdateTagParams) error {
	_, err := db.ExecContext(ctx, updateTag,
		arg.Name,
		arg.ColorR,
		arg.ColorG,
		arg.ColorB,
		arg.ID,
	)
	return err
}

const upsertAlliance = `-- name: UpsertAlliance :one
INSERT INTO alliances ("id", "name", "ticker", "picture")
VALUES (?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "ticker" = excluded.ticker
RETURNING id, name, ticker, picture
`

type UpsertAllianceParams struct {
	ID      sql.NullInt64
	Name    sql.NullString
	Ticker  sql.NullString
	Picture sql.NullString
}

func (q *Queries) UpsertAlliance(ctx context.Context, db DBTX, arg UpsertAllianceParams) (Alliance, error) {
	row := db.QueryRowContext(ctx, upsertAlliance,
		arg.ID,
		arg.Name,
		arg.Ticker,
		arg.Picture,
	)
	var i Alliance
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ticker,
		&i.Picture,
	)
	return i, err
}

const upsertCharacter = `-- name: UpsertCharacter :one
INSERT INTO characters ("id", "name", "picture", "corporation_id")
VALUES (?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "corporation_id" = excluded.corporation_id
RETURNING id, name, picture, corporation_id
`

type UpsertCharacterParams struct {
	ID            int64
	Name          string
	Picture       string
	CorporationID int64
}

func (q *Queries) UpsertCharacter(ctx context.Context, db DBTX, arg UpsertCharacterParams) (Character, error) {
	row := db.QueryRowContext(ctx, upsertCharacter,
		arg.ID,
		arg.Name,
		arg.Picture,
		arg.CorporationID,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Picture,
		&i.CorporationID,
	)
	return i, err
}

const upsertCharacterSkill = `-- name: UpsertCharacterSkill :one
INSERT INTO character_skills ("character_id", "skill_id", "skill_level")
VALUES (?, ?, ?)
ON CONFLICT ("character_id", "skill_id") DO UPDATE
SET
    "skill_level" = excluded.skill_level
RETURNING character_id, skill_id, skill_level
`

type UpsertCharacterSkillParams struct {
	CharacterID int64
	SkillID     int64
	SkillLevel  int64
}

func (q *Queries) UpsertCharacterSkill(ctx context.Context, db DBTX, arg UpsertCharacterSkillParams) (CharacterSkill, error) {
	row := db.QueryRowContext(ctx, upsertCharacterSkill, arg.CharacterID, arg.SkillID, arg.SkillLevel)
	var i CharacterSkill
	err := row.Scan(&i.CharacterID, &i.SkillID, &i.SkillLevel)
	return i, err
}

const upsertCorporation = `-- name: UpsertCorporation :one
INSERT INTO corporations ("id", "name", "ticker", "alliance_id", "picture")
VALUES (?, ?, ?, ?, ?)
ON CONFLICT ("id") DO UPDATE
SET
    "name" = excluded.name,
    "picture" = excluded.picture,
    "alliance_id" = excluded.alliance_id,
    "ticker" = excluded.ticker
RETURNING id, alliance_id, name, ticker, picture
`

type UpsertCorporationParams struct {
	ID         int64
	Name       string
	Ticker     string
	AllianceID sql.NullInt64
	Picture    string
}

func (q *Queries) UpsertCorporation(ctx context.Context, db DBTX, arg UpsertCorporationParams) (Corporation, error) {
	row := db.QueryRowContext(ctx, upsertCorporation,
		arg.ID,
		arg.Name,
		arg.Ticker,
		arg.AllianceID,
		arg.Picture,
	)
	var i Corporation
	err := row.Scan(
		&i.ID,
		&i.AllianceID,
		&i.Name,
		&i.Ticker,
		&i.Picture,
	)
	return i, err
}

const upsertTagSkill = `-- name: UpsertTagSkill :one
INSERT INTO tag_skills ("tag_id", "skill_id", "skill_level")
VALUES (?, ?, ?)
ON CONFLICT ("tag_id", "skill_id") DO UPDATE
SET
    "skill_level" = excluded.skill_level
RETURNING tag_id, skill_id, skill_level
`

type UpsertTagSkillParams struct {
	TagID      int64
	SkillID    int64
	SkillLevel int64
}

func (q *Queries) UpsertTagSkill(ctx context.Context, db DBTX, arg UpsertTagSkillParams) (TagSkill, error) {
	row := db.QueryRowContext(ctx, upsertTagSkill, arg.TagID, arg.SkillID, arg.SkillLevel)
	var i TagSkill
	err := row.Scan(&i.TagID, &i.SkillID, &i.SkillLevel)
	return i, err
}

const upsertToken = `-- name: UpsertToken :one

INSERT INTO tokens ("character_id", "access_token", "refresh_token", "token_type", "expiration")
VALUES (?, ?, ?, ?, ?)
ON CONFLICT ("character_id") DO UPDATE
SET
    "access_token" = excluded.access_token,
    "refresh_token" = excluded.refresh_token,
    "token_type" = excluded.token_type,
    "expiration" = excluded.expiration
RETURNING id, character_id, access_token, refresh_token, token_type, expiration
`

type UpsertTokenParams struct {
	CharacterID  int64
	AccessToken  string
	RefreshToken string
	TokenType    string
	Expiration   time.Time
}

func (q *Queries) UpsertToken(ctx context.Context, db DBTX, arg UpsertTokenParams) (Token, error) {
	row := db.QueryRowContext(ctx, upsertToken,
		arg.CharacterID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.TokenType,
		arg.Expiration,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.CharacterID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.TokenType,
		&i.Expiration,
	)
	return i, err
}
