// Code generated by counterfeiter. DO NOT EDIT.
package repositoryfakes

import (
	"context"
	"image/color"
	"sync"
	"time"

	"github.com/kava-forge/eve-alts/pkg/database"
	"github.com/kava-forge/eve-alts/pkg/repository"
	"github.com/kava-forge/eve-alts/pkg/repository/internal/appdb"
)

type FakeAppData struct {
	DeleteCharacterStub        func(context.Context, int64, database.Tx) error
	deleteCharacterMutex       sync.RWMutex
	deleteCharacterArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}
	deleteCharacterReturns struct {
		result1 error
	}
	deleteCharacterReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCharacterSkillsStub        func(context.Context, int64, []int64, database.Tx) error
	deleteCharacterSkillsMutex       sync.RWMutex
	deleteCharacterSkillsArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 []int64
		arg4 database.Tx
	}
	deleteCharacterSkillsReturns struct {
		result1 error
	}
	deleteCharacterSkillsReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTagStub        func(context.Context, int64, database.Tx) error
	deleteTagMutex       sync.RWMutex
	deleteTagArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}
	deleteTagReturns struct {
		result1 error
	}
	deleteTagReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTagSkillsStub        func(context.Context, int64, []int64, database.Tx) error
	deleteTagSkillsMutex       sync.RWMutex
	deleteTagSkillsArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 []int64
		arg4 database.Tx
	}
	deleteTagSkillsReturns struct {
		result1 error
	}
	deleteTagSkillsReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllCharacterSkillsStub        func(context.Context, int64, database.Tx) ([]appdb.CharacterSkill, error)
	getAllCharacterSkillsMutex       sync.RWMutex
	getAllCharacterSkillsArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}
	getAllCharacterSkillsReturns struct {
		result1 []appdb.CharacterSkill
		result2 error
	}
	getAllCharacterSkillsReturnsOnCall map[int]struct {
		result1 []appdb.CharacterSkill
		result2 error
	}
	GetAllCharactersStub        func(context.Context, database.Tx) ([]*repository.CharacterDBData, error)
	getAllCharactersMutex       sync.RWMutex
	getAllCharactersArgsForCall []struct {
		arg1 context.Context
		arg2 database.Tx
	}
	getAllCharactersReturns struct {
		result1 []*repository.CharacterDBData
		result2 error
	}
	getAllCharactersReturnsOnCall map[int]struct {
		result1 []*repository.CharacterDBData
		result2 error
	}
	GetAllTagSkillsStub        func(context.Context, int64, database.Tx) ([]appdb.TagSkill, error)
	getAllTagSkillsMutex       sync.RWMutex
	getAllTagSkillsArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}
	getAllTagSkillsReturns struct {
		result1 []appdb.TagSkill
		result2 error
	}
	getAllTagSkillsReturnsOnCall map[int]struct {
		result1 []appdb.TagSkill
		result2 error
	}
	GetAllTagsStub        func(context.Context, database.Tx) ([]*repository.TagDBData, error)
	getAllTagsMutex       sync.RWMutex
	getAllTagsArgsForCall []struct {
		arg1 context.Context
		arg2 database.Tx
	}
	getAllTagsReturns struct {
		result1 []*repository.TagDBData
		result2 error
	}
	getAllTagsReturnsOnCall map[int]struct {
		result1 []*repository.TagDBData
		result2 error
	}
	GetTokenForCharacterStub        func(context.Context, int64, database.Tx) (appdb.Token, error)
	getTokenForCharacterMutex       sync.RWMutex
	getTokenForCharacterArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}
	getTokenForCharacterReturns struct {
		result1 appdb.Token
		result2 error
	}
	getTokenForCharacterReturnsOnCall map[int]struct {
		result1 appdb.Token
		result2 error
	}
	InsertTagStub        func(context.Context, string, color.Color, database.Tx) (appdb.Tag, error)
	insertTagMutex       sync.RWMutex
	insertTagArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 color.Color
		arg4 database.Tx
	}
	insertTagReturns struct {
		result1 appdb.Tag
		result2 error
	}
	insertTagReturnsOnCall map[int]struct {
		result1 appdb.Tag
		result2 error
	}
	UpdateTagStub        func(context.Context, int64, string, color.Color, database.Tx) error
	updateTagMutex       sync.RWMutex
	updateTagArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 color.Color
		arg5 database.Tx
	}
	updateTagReturns struct {
		result1 error
	}
	updateTagReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertAllianceStub        func(context.Context, int64, string, string, string, database.Tx) (appdb.Alliance, error)
	upsertAllianceMutex       sync.RWMutex
	upsertAllianceArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 database.Tx
	}
	upsertAllianceReturns struct {
		result1 appdb.Alliance
		result2 error
	}
	upsertAllianceReturnsOnCall map[int]struct {
		result1 appdb.Alliance
		result2 error
	}
	UpsertCharacterStub        func(context.Context, int64, string, string, int64, database.Tx) (appdb.Character, error)
	upsertCharacterMutex       sync.RWMutex
	upsertCharacterArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 int64
		arg6 database.Tx
	}
	upsertCharacterReturns struct {
		result1 appdb.Character
		result2 error
	}
	upsertCharacterReturnsOnCall map[int]struct {
		result1 appdb.Character
		result2 error
	}
	UpsertCharacterSkillStub        func(context.Context, int64, int64, int64, database.Tx) (appdb.CharacterSkill, error)
	upsertCharacterSkillMutex       sync.RWMutex
	upsertCharacterSkillArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
		arg4 int64
		arg5 database.Tx
	}
	upsertCharacterSkillReturns struct {
		result1 appdb.CharacterSkill
		result2 error
	}
	upsertCharacterSkillReturnsOnCall map[int]struct {
		result1 appdb.CharacterSkill
		result2 error
	}
	UpsertCorporationStub        func(context.Context, int64, string, string, string, int64, database.Tx) (appdb.Corporation, error)
	upsertCorporationMutex       sync.RWMutex
	upsertCorporationArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 int64
		arg7 database.Tx
	}
	upsertCorporationReturns struct {
		result1 appdb.Corporation
		result2 error
	}
	upsertCorporationReturnsOnCall map[int]struct {
		result1 appdb.Corporation
		result2 error
	}
	UpsertTagSkillStub        func(context.Context, int64, int64, int64, database.Tx) (appdb.TagSkill, error)
	upsertTagSkillMutex       sync.RWMutex
	upsertTagSkillArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
		arg4 int64
		arg5 database.Tx
	}
	upsertTagSkillReturns struct {
		result1 appdb.TagSkill
		result2 error
	}
	upsertTagSkillReturnsOnCall map[int]struct {
		result1 appdb.TagSkill
		result2 error
	}
	UpsertTokenStub        func(context.Context, int64, string, string, string, time.Time, database.Tx) (appdb.Token, error)
	upsertTokenMutex       sync.RWMutex
	upsertTokenArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Time
		arg7 database.Tx
	}
	upsertTokenReturns struct {
		result1 appdb.Token
		result2 error
	}
	upsertTokenReturnsOnCall map[int]struct {
		result1 appdb.Token
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAppData) DeleteCharacter(arg1 context.Context, arg2 int64, arg3 database.Tx) error {
	fake.deleteCharacterMutex.Lock()
	ret, specificReturn := fake.deleteCharacterReturnsOnCall[len(fake.deleteCharacterArgsForCall)]
	fake.deleteCharacterArgsForCall = append(fake.deleteCharacterArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}{arg1, arg2, arg3})
	stub := fake.DeleteCharacterStub
	fakeReturns := fake.deleteCharacterReturns
	fake.recordInvocation("DeleteCharacter", []interface{}{arg1, arg2, arg3})
	fake.deleteCharacterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAppData) DeleteCharacterCallCount() int {
	fake.deleteCharacterMutex.RLock()
	defer fake.deleteCharacterMutex.RUnlock()
	return len(fake.deleteCharacterArgsForCall)
}

func (fake *FakeAppData) DeleteCharacterCalls(stub func(context.Context, int64, database.Tx) error) {
	fake.deleteCharacterMutex.Lock()
	defer fake.deleteCharacterMutex.Unlock()
	fake.DeleteCharacterStub = stub
}

func (fake *FakeAppData) DeleteCharacterArgsForCall(i int) (context.Context, int64, database.Tx) {
	fake.deleteCharacterMutex.RLock()
	defer fake.deleteCharacterMutex.RUnlock()
	argsForCall := fake.deleteCharacterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppData) DeleteCharacterReturns(result1 error) {
	fake.deleteCharacterMutex.Lock()
	defer fake.deleteCharacterMutex.Unlock()
	fake.DeleteCharacterStub = nil
	fake.deleteCharacterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteCharacterReturnsOnCall(i int, result1 error) {
	fake.deleteCharacterMutex.Lock()
	defer fake.deleteCharacterMutex.Unlock()
	fake.DeleteCharacterStub = nil
	if fake.deleteCharacterReturnsOnCall == nil {
		fake.deleteCharacterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCharacterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteCharacterSkills(arg1 context.Context, arg2 int64, arg3 []int64, arg4 database.Tx) error {
	var arg3Copy []int64
	if arg3 != nil {
		arg3Copy = make([]int64, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.deleteCharacterSkillsMutex.Lock()
	ret, specificReturn := fake.deleteCharacterSkillsReturnsOnCall[len(fake.deleteCharacterSkillsArgsForCall)]
	fake.deleteCharacterSkillsArgsForCall = append(fake.deleteCharacterSkillsArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 []int64
		arg4 database.Tx
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.DeleteCharacterSkillsStub
	fakeReturns := fake.deleteCharacterSkillsReturns
	fake.recordInvocation("DeleteCharacterSkills", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.deleteCharacterSkillsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAppData) DeleteCharacterSkillsCallCount() int {
	fake.deleteCharacterSkillsMutex.RLock()
	defer fake.deleteCharacterSkillsMutex.RUnlock()
	return len(fake.deleteCharacterSkillsArgsForCall)
}

func (fake *FakeAppData) DeleteCharacterSkillsCalls(stub func(context.Context, int64, []int64, database.Tx) error) {
	fake.deleteCharacterSkillsMutex.Lock()
	defer fake.deleteCharacterSkillsMutex.Unlock()
	fake.DeleteCharacterSkillsStub = stub
}

func (fake *FakeAppData) DeleteCharacterSkillsArgsForCall(i int) (context.Context, int64, []int64, database.Tx) {
	fake.deleteCharacterSkillsMutex.RLock()
	defer fake.deleteCharacterSkillsMutex.RUnlock()
	argsForCall := fake.deleteCharacterSkillsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAppData) DeleteCharacterSkillsReturns(result1 error) {
	fake.deleteCharacterSkillsMutex.Lock()
	defer fake.deleteCharacterSkillsMutex.Unlock()
	fake.DeleteCharacterSkillsStub = nil
	fake.deleteCharacterSkillsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteCharacterSkillsReturnsOnCall(i int, result1 error) {
	fake.deleteCharacterSkillsMutex.Lock()
	defer fake.deleteCharacterSkillsMutex.Unlock()
	fake.DeleteCharacterSkillsStub = nil
	if fake.deleteCharacterSkillsReturnsOnCall == nil {
		fake.deleteCharacterSkillsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCharacterSkillsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteTag(arg1 context.Context, arg2 int64, arg3 database.Tx) error {
	fake.deleteTagMutex.Lock()
	ret, specificReturn := fake.deleteTagReturnsOnCall[len(fake.deleteTagArgsForCall)]
	fake.deleteTagArgsForCall = append(fake.deleteTagArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}{arg1, arg2, arg3})
	stub := fake.DeleteTagStub
	fakeReturns := fake.deleteTagReturns
	fake.recordInvocation("DeleteTag", []interface{}{arg1, arg2, arg3})
	fake.deleteTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAppData) DeleteTagCallCount() int {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	return len(fake.deleteTagArgsForCall)
}

func (fake *FakeAppData) DeleteTagCalls(stub func(context.Context, int64, database.Tx) error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = stub
}

func (fake *FakeAppData) DeleteTagArgsForCall(i int) (context.Context, int64, database.Tx) {
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	argsForCall := fake.deleteTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppData) DeleteTagReturns(result1 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	fake.deleteTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteTagReturnsOnCall(i int, result1 error) {
	fake.deleteTagMutex.Lock()
	defer fake.deleteTagMutex.Unlock()
	fake.DeleteTagStub = nil
	if fake.deleteTagReturnsOnCall == nil {
		fake.deleteTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteTagSkills(arg1 context.Context, arg2 int64, arg3 []int64, arg4 database.Tx) error {
	var arg3Copy []int64
	if arg3 != nil {
		arg3Copy = make([]int64, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.deleteTagSkillsMutex.Lock()
	ret, specificReturn := fake.deleteTagSkillsReturnsOnCall[len(fake.deleteTagSkillsArgsForCall)]
	fake.deleteTagSkillsArgsForCall = append(fake.deleteTagSkillsArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 []int64
		arg4 database.Tx
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.DeleteTagSkillsStub
	fakeReturns := fake.deleteTagSkillsReturns
	fake.recordInvocation("DeleteTagSkills", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.deleteTagSkillsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAppData) DeleteTagSkillsCallCount() int {
	fake.deleteTagSkillsMutex.RLock()
	defer fake.deleteTagSkillsMutex.RUnlock()
	return len(fake.deleteTagSkillsArgsForCall)
}

func (fake *FakeAppData) DeleteTagSkillsCalls(stub func(context.Context, int64, []int64, database.Tx) error) {
	fake.deleteTagSkillsMutex.Lock()
	defer fake.deleteTagSkillsMutex.Unlock()
	fake.DeleteTagSkillsStub = stub
}

func (fake *FakeAppData) DeleteTagSkillsArgsForCall(i int) (context.Context, int64, []int64, database.Tx) {
	fake.deleteTagSkillsMutex.RLock()
	defer fake.deleteTagSkillsMutex.RUnlock()
	argsForCall := fake.deleteTagSkillsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAppData) DeleteTagSkillsReturns(result1 error) {
	fake.deleteTagSkillsMutex.Lock()
	defer fake.deleteTagSkillsMutex.Unlock()
	fake.DeleteTagSkillsStub = nil
	fake.deleteTagSkillsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) DeleteTagSkillsReturnsOnCall(i int, result1 error) {
	fake.deleteTagSkillsMutex.Lock()
	defer fake.deleteTagSkillsMutex.Unlock()
	fake.DeleteTagSkillsStub = nil
	if fake.deleteTagSkillsReturnsOnCall == nil {
		fake.deleteTagSkillsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTagSkillsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) GetAllCharacterSkills(arg1 context.Context, arg2 int64, arg3 database.Tx) ([]appdb.CharacterSkill, error) {
	fake.getAllCharacterSkillsMutex.Lock()
	ret, specificReturn := fake.getAllCharacterSkillsReturnsOnCall[len(fake.getAllCharacterSkillsArgsForCall)]
	fake.getAllCharacterSkillsArgsForCall = append(fake.getAllCharacterSkillsArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}{arg1, arg2, arg3})
	stub := fake.GetAllCharacterSkillsStub
	fakeReturns := fake.getAllCharacterSkillsReturns
	fake.recordInvocation("GetAllCharacterSkills", []interface{}{arg1, arg2, arg3})
	fake.getAllCharacterSkillsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) GetAllCharacterSkillsCallCount() int {
	fake.getAllCharacterSkillsMutex.RLock()
	defer fake.getAllCharacterSkillsMutex.RUnlock()
	return len(fake.getAllCharacterSkillsArgsForCall)
}

func (fake *FakeAppData) GetAllCharacterSkillsCalls(stub func(context.Context, int64, database.Tx) ([]appdb.CharacterSkill, error)) {
	fake.getAllCharacterSkillsMutex.Lock()
	defer fake.getAllCharacterSkillsMutex.Unlock()
	fake.GetAllCharacterSkillsStub = stub
}

func (fake *FakeAppData) GetAllCharacterSkillsArgsForCall(i int) (context.Context, int64, database.Tx) {
	fake.getAllCharacterSkillsMutex.RLock()
	defer fake.getAllCharacterSkillsMutex.RUnlock()
	argsForCall := fake.getAllCharacterSkillsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppData) GetAllCharacterSkillsReturns(result1 []appdb.CharacterSkill, result2 error) {
	fake.getAllCharacterSkillsMutex.Lock()
	defer fake.getAllCharacterSkillsMutex.Unlock()
	fake.GetAllCharacterSkillsStub = nil
	fake.getAllCharacterSkillsReturns = struct {
		result1 []appdb.CharacterSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllCharacterSkillsReturnsOnCall(i int, result1 []appdb.CharacterSkill, result2 error) {
	fake.getAllCharacterSkillsMutex.Lock()
	defer fake.getAllCharacterSkillsMutex.Unlock()
	fake.GetAllCharacterSkillsStub = nil
	if fake.getAllCharacterSkillsReturnsOnCall == nil {
		fake.getAllCharacterSkillsReturnsOnCall = make(map[int]struct {
			result1 []appdb.CharacterSkill
			result2 error
		})
	}
	fake.getAllCharacterSkillsReturnsOnCall[i] = struct {
		result1 []appdb.CharacterSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllCharacters(arg1 context.Context, arg2 database.Tx) ([]*repository.CharacterDBData, error) {
	fake.getAllCharactersMutex.Lock()
	ret, specificReturn := fake.getAllCharactersReturnsOnCall[len(fake.getAllCharactersArgsForCall)]
	fake.getAllCharactersArgsForCall = append(fake.getAllCharactersArgsForCall, struct {
		arg1 context.Context
		arg2 database.Tx
	}{arg1, arg2})
	stub := fake.GetAllCharactersStub
	fakeReturns := fake.getAllCharactersReturns
	fake.recordInvocation("GetAllCharacters", []interface{}{arg1, arg2})
	fake.getAllCharactersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) GetAllCharactersCallCount() int {
	fake.getAllCharactersMutex.RLock()
	defer fake.getAllCharactersMutex.RUnlock()
	return len(fake.getAllCharactersArgsForCall)
}

func (fake *FakeAppData) GetAllCharactersCalls(stub func(context.Context, database.Tx) ([]*repository.CharacterDBData, error)) {
	fake.getAllCharactersMutex.Lock()
	defer fake.getAllCharactersMutex.Unlock()
	fake.GetAllCharactersStub = stub
}

func (fake *FakeAppData) GetAllCharactersArgsForCall(i int) (context.Context, database.Tx) {
	fake.getAllCharactersMutex.RLock()
	defer fake.getAllCharactersMutex.RUnlock()
	argsForCall := fake.getAllCharactersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAppData) GetAllCharactersReturns(result1 []*repository.CharacterDBData, result2 error) {
	fake.getAllCharactersMutex.Lock()
	defer fake.getAllCharactersMutex.Unlock()
	fake.GetAllCharactersStub = nil
	fake.getAllCharactersReturns = struct {
		result1 []*repository.CharacterDBData
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllCharactersReturnsOnCall(i int, result1 []*repository.CharacterDBData, result2 error) {
	fake.getAllCharactersMutex.Lock()
	defer fake.getAllCharactersMutex.Unlock()
	fake.GetAllCharactersStub = nil
	if fake.getAllCharactersReturnsOnCall == nil {
		fake.getAllCharactersReturnsOnCall = make(map[int]struct {
			result1 []*repository.CharacterDBData
			result2 error
		})
	}
	fake.getAllCharactersReturnsOnCall[i] = struct {
		result1 []*repository.CharacterDBData
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllTagSkills(arg1 context.Context, arg2 int64, arg3 database.Tx) ([]appdb.TagSkill, error) {
	fake.getAllTagSkillsMutex.Lock()
	ret, specificReturn := fake.getAllTagSkillsReturnsOnCall[len(fake.getAllTagSkillsArgsForCall)]
	fake.getAllTagSkillsArgsForCall = append(fake.getAllTagSkillsArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}{arg1, arg2, arg3})
	stub := fake.GetAllTagSkillsStub
	fakeReturns := fake.getAllTagSkillsReturns
	fake.recordInvocation("GetAllTagSkills", []interface{}{arg1, arg2, arg3})
	fake.getAllTagSkillsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) GetAllTagSkillsCallCount() int {
	fake.getAllTagSkillsMutex.RLock()
	defer fake.getAllTagSkillsMutex.RUnlock()
	return len(fake.getAllTagSkillsArgsForCall)
}

func (fake *FakeAppData) GetAllTagSkillsCalls(stub func(context.Context, int64, database.Tx) ([]appdb.TagSkill, error)) {
	fake.getAllTagSkillsMutex.Lock()
	defer fake.getAllTagSkillsMutex.Unlock()
	fake.GetAllTagSkillsStub = stub
}

func (fake *FakeAppData) GetAllTagSkillsArgsForCall(i int) (context.Context, int64, database.Tx) {
	fake.getAllTagSkillsMutex.RLock()
	defer fake.getAllTagSkillsMutex.RUnlock()
	argsForCall := fake.getAllTagSkillsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppData) GetAllTagSkillsReturns(result1 []appdb.TagSkill, result2 error) {
	fake.getAllTagSkillsMutex.Lock()
	defer fake.getAllTagSkillsMutex.Unlock()
	fake.GetAllTagSkillsStub = nil
	fake.getAllTagSkillsReturns = struct {
		result1 []appdb.TagSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllTagSkillsReturnsOnCall(i int, result1 []appdb.TagSkill, result2 error) {
	fake.getAllTagSkillsMutex.Lock()
	defer fake.getAllTagSkillsMutex.Unlock()
	fake.GetAllTagSkillsStub = nil
	if fake.getAllTagSkillsReturnsOnCall == nil {
		fake.getAllTagSkillsReturnsOnCall = make(map[int]struct {
			result1 []appdb.TagSkill
			result2 error
		})
	}
	fake.getAllTagSkillsReturnsOnCall[i] = struct {
		result1 []appdb.TagSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllTags(arg1 context.Context, arg2 database.Tx) ([]*repository.TagDBData, error) {
	fake.getAllTagsMutex.Lock()
	ret, specificReturn := fake.getAllTagsReturnsOnCall[len(fake.getAllTagsArgsForCall)]
	fake.getAllTagsArgsForCall = append(fake.getAllTagsArgsForCall, struct {
		arg1 context.Context
		arg2 database.Tx
	}{arg1, arg2})
	stub := fake.GetAllTagsStub
	fakeReturns := fake.getAllTagsReturns
	fake.recordInvocation("GetAllTags", []interface{}{arg1, arg2})
	fake.getAllTagsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) GetAllTagsCallCount() int {
	fake.getAllTagsMutex.RLock()
	defer fake.getAllTagsMutex.RUnlock()
	return len(fake.getAllTagsArgsForCall)
}

func (fake *FakeAppData) GetAllTagsCalls(stub func(context.Context, database.Tx) ([]*repository.TagDBData, error)) {
	fake.getAllTagsMutex.Lock()
	defer fake.getAllTagsMutex.Unlock()
	fake.GetAllTagsStub = stub
}

func (fake *FakeAppData) GetAllTagsArgsForCall(i int) (context.Context, database.Tx) {
	fake.getAllTagsMutex.RLock()
	defer fake.getAllTagsMutex.RUnlock()
	argsForCall := fake.getAllTagsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAppData) GetAllTagsReturns(result1 []*repository.TagDBData, result2 error) {
	fake.getAllTagsMutex.Lock()
	defer fake.getAllTagsMutex.Unlock()
	fake.GetAllTagsStub = nil
	fake.getAllTagsReturns = struct {
		result1 []*repository.TagDBData
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetAllTagsReturnsOnCall(i int, result1 []*repository.TagDBData, result2 error) {
	fake.getAllTagsMutex.Lock()
	defer fake.getAllTagsMutex.Unlock()
	fake.GetAllTagsStub = nil
	if fake.getAllTagsReturnsOnCall == nil {
		fake.getAllTagsReturnsOnCall = make(map[int]struct {
			result1 []*repository.TagDBData
			result2 error
		})
	}
	fake.getAllTagsReturnsOnCall[i] = struct {
		result1 []*repository.TagDBData
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetTokenForCharacter(arg1 context.Context, arg2 int64, arg3 database.Tx) (appdb.Token, error) {
	fake.getTokenForCharacterMutex.Lock()
	ret, specificReturn := fake.getTokenForCharacterReturnsOnCall[len(fake.getTokenForCharacterArgsForCall)]
	fake.getTokenForCharacterArgsForCall = append(fake.getTokenForCharacterArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 database.Tx
	}{arg1, arg2, arg3})
	stub := fake.GetTokenForCharacterStub
	fakeReturns := fake.getTokenForCharacterReturns
	fake.recordInvocation("GetTokenForCharacter", []interface{}{arg1, arg2, arg3})
	fake.getTokenForCharacterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) GetTokenForCharacterCallCount() int {
	fake.getTokenForCharacterMutex.RLock()
	defer fake.getTokenForCharacterMutex.RUnlock()
	return len(fake.getTokenForCharacterArgsForCall)
}

func (fake *FakeAppData) GetTokenForCharacterCalls(stub func(context.Context, int64, database.Tx) (appdb.Token, error)) {
	fake.getTokenForCharacterMutex.Lock()
	defer fake.getTokenForCharacterMutex.Unlock()
	fake.GetTokenForCharacterStub = stub
}

func (fake *FakeAppData) GetTokenForCharacterArgsForCall(i int) (context.Context, int64, database.Tx) {
	fake.getTokenForCharacterMutex.RLock()
	defer fake.getTokenForCharacterMutex.RUnlock()
	argsForCall := fake.getTokenForCharacterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeAppData) GetTokenForCharacterReturns(result1 appdb.Token, result2 error) {
	fake.getTokenForCharacterMutex.Lock()
	defer fake.getTokenForCharacterMutex.Unlock()
	fake.GetTokenForCharacterStub = nil
	fake.getTokenForCharacterReturns = struct {
		result1 appdb.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) GetTokenForCharacterReturnsOnCall(i int, result1 appdb.Token, result2 error) {
	fake.getTokenForCharacterMutex.Lock()
	defer fake.getTokenForCharacterMutex.Unlock()
	fake.GetTokenForCharacterStub = nil
	if fake.getTokenForCharacterReturnsOnCall == nil {
		fake.getTokenForCharacterReturnsOnCall = make(map[int]struct {
			result1 appdb.Token
			result2 error
		})
	}
	fake.getTokenForCharacterReturnsOnCall[i] = struct {
		result1 appdb.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) InsertTag(arg1 context.Context, arg2 string, arg3 color.Color, arg4 database.Tx) (appdb.Tag, error) {
	fake.insertTagMutex.Lock()
	ret, specificReturn := fake.insertTagReturnsOnCall[len(fake.insertTagArgsForCall)]
	fake.insertTagArgsForCall = append(fake.insertTagArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 color.Color
		arg4 database.Tx
	}{arg1, arg2, arg3, arg4})
	stub := fake.InsertTagStub
	fakeReturns := fake.insertTagReturns
	fake.recordInvocation("InsertTag", []interface{}{arg1, arg2, arg3, arg4})
	fake.insertTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) InsertTagCallCount() int {
	fake.insertTagMutex.RLock()
	defer fake.insertTagMutex.RUnlock()
	return len(fake.insertTagArgsForCall)
}

func (fake *FakeAppData) InsertTagCalls(stub func(context.Context, string, color.Color, database.Tx) (appdb.Tag, error)) {
	fake.insertTagMutex.Lock()
	defer fake.insertTagMutex.Unlock()
	fake.InsertTagStub = stub
}

func (fake *FakeAppData) InsertTagArgsForCall(i int) (context.Context, string, color.Color, database.Tx) {
	fake.insertTagMutex.RLock()
	defer fake.insertTagMutex.RUnlock()
	argsForCall := fake.insertTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeAppData) InsertTagReturns(result1 appdb.Tag, result2 error) {
	fake.insertTagMutex.Lock()
	defer fake.insertTagMutex.Unlock()
	fake.InsertTagStub = nil
	fake.insertTagReturns = struct {
		result1 appdb.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) InsertTagReturnsOnCall(i int, result1 appdb.Tag, result2 error) {
	fake.insertTagMutex.Lock()
	defer fake.insertTagMutex.Unlock()
	fake.InsertTagStub = nil
	if fake.insertTagReturnsOnCall == nil {
		fake.insertTagReturnsOnCall = make(map[int]struct {
			result1 appdb.Tag
			result2 error
		})
	}
	fake.insertTagReturnsOnCall[i] = struct {
		result1 appdb.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpdateTag(arg1 context.Context, arg2 int64, arg3 string, arg4 color.Color, arg5 database.Tx) error {
	fake.updateTagMutex.Lock()
	ret, specificReturn := fake.updateTagReturnsOnCall[len(fake.updateTagArgsForCall)]
	fake.updateTagArgsForCall = append(fake.updateTagArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 color.Color
		arg5 database.Tx
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateTagStub
	fakeReturns := fake.updateTagReturns
	fake.recordInvocation("UpdateTag", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAppData) UpdateTagCallCount() int {
	fake.updateTagMutex.RLock()
	defer fake.updateTagMutex.RUnlock()
	return len(fake.updateTagArgsForCall)
}

func (fake *FakeAppData) UpdateTagCalls(stub func(context.Context, int64, string, color.Color, database.Tx) error) {
	fake.updateTagMutex.Lock()
	defer fake.updateTagMutex.Unlock()
	fake.UpdateTagStub = stub
}

func (fake *FakeAppData) UpdateTagArgsForCall(i int) (context.Context, int64, string, color.Color, database.Tx) {
	fake.updateTagMutex.RLock()
	defer fake.updateTagMutex.RUnlock()
	argsForCall := fake.updateTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAppData) UpdateTagReturns(result1 error) {
	fake.updateTagMutex.Lock()
	defer fake.updateTagMutex.Unlock()
	fake.UpdateTagStub = nil
	fake.updateTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) UpdateTagReturnsOnCall(i int, result1 error) {
	fake.updateTagMutex.Lock()
	defer fake.updateTagMutex.Unlock()
	fake.UpdateTagStub = nil
	if fake.updateTagReturnsOnCall == nil {
		fake.updateTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppData) UpsertAlliance(arg1 context.Context, arg2 int64, arg3 string, arg4 string, arg5 string, arg6 database.Tx) (appdb.Alliance, error) {
	fake.upsertAllianceMutex.Lock()
	ret, specificReturn := fake.upsertAllianceReturnsOnCall[len(fake.upsertAllianceArgsForCall)]
	fake.upsertAllianceArgsForCall = append(fake.upsertAllianceArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 database.Tx
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpsertAllianceStub
	fakeReturns := fake.upsertAllianceReturns
	fake.recordInvocation("UpsertAlliance", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.upsertAllianceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertAllianceCallCount() int {
	fake.upsertAllianceMutex.RLock()
	defer fake.upsertAllianceMutex.RUnlock()
	return len(fake.upsertAllianceArgsForCall)
}

func (fake *FakeAppData) UpsertAllianceCalls(stub func(context.Context, int64, string, string, string, database.Tx) (appdb.Alliance, error)) {
	fake.upsertAllianceMutex.Lock()
	defer fake.upsertAllianceMutex.Unlock()
	fake.UpsertAllianceStub = stub
}

func (fake *FakeAppData) UpsertAllianceArgsForCall(i int) (context.Context, int64, string, string, string, database.Tx) {
	fake.upsertAllianceMutex.RLock()
	defer fake.upsertAllianceMutex.RUnlock()
	argsForCall := fake.upsertAllianceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeAppData) UpsertAllianceReturns(result1 appdb.Alliance, result2 error) {
	fake.upsertAllianceMutex.Lock()
	defer fake.upsertAllianceMutex.Unlock()
	fake.UpsertAllianceStub = nil
	fake.upsertAllianceReturns = struct {
		result1 appdb.Alliance
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertAllianceReturnsOnCall(i int, result1 appdb.Alliance, result2 error) {
	fake.upsertAllianceMutex.Lock()
	defer fake.upsertAllianceMutex.Unlock()
	fake.UpsertAllianceStub = nil
	if fake.upsertAllianceReturnsOnCall == nil {
		fake.upsertAllianceReturnsOnCall = make(map[int]struct {
			result1 appdb.Alliance
			result2 error
		})
	}
	fake.upsertAllianceReturnsOnCall[i] = struct {
		result1 appdb.Alliance
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCharacter(arg1 context.Context, arg2 int64, arg3 string, arg4 string, arg5 int64, arg6 database.Tx) (appdb.Character, error) {
	fake.upsertCharacterMutex.Lock()
	ret, specificReturn := fake.upsertCharacterReturnsOnCall[len(fake.upsertCharacterArgsForCall)]
	fake.upsertCharacterArgsForCall = append(fake.upsertCharacterArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 int64
		arg6 database.Tx
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpsertCharacterStub
	fakeReturns := fake.upsertCharacterReturns
	fake.recordInvocation("UpsertCharacter", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.upsertCharacterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertCharacterCallCount() int {
	fake.upsertCharacterMutex.RLock()
	defer fake.upsertCharacterMutex.RUnlock()
	return len(fake.upsertCharacterArgsForCall)
}

func (fake *FakeAppData) UpsertCharacterCalls(stub func(context.Context, int64, string, string, int64, database.Tx) (appdb.Character, error)) {
	fake.upsertCharacterMutex.Lock()
	defer fake.upsertCharacterMutex.Unlock()
	fake.UpsertCharacterStub = stub
}

func (fake *FakeAppData) UpsertCharacterArgsForCall(i int) (context.Context, int64, string, string, int64, database.Tx) {
	fake.upsertCharacterMutex.RLock()
	defer fake.upsertCharacterMutex.RUnlock()
	argsForCall := fake.upsertCharacterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeAppData) UpsertCharacterReturns(result1 appdb.Character, result2 error) {
	fake.upsertCharacterMutex.Lock()
	defer fake.upsertCharacterMutex.Unlock()
	fake.UpsertCharacterStub = nil
	fake.upsertCharacterReturns = struct {
		result1 appdb.Character
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCharacterReturnsOnCall(i int, result1 appdb.Character, result2 error) {
	fake.upsertCharacterMutex.Lock()
	defer fake.upsertCharacterMutex.Unlock()
	fake.UpsertCharacterStub = nil
	if fake.upsertCharacterReturnsOnCall == nil {
		fake.upsertCharacterReturnsOnCall = make(map[int]struct {
			result1 appdb.Character
			result2 error
		})
	}
	fake.upsertCharacterReturnsOnCall[i] = struct {
		result1 appdb.Character
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCharacterSkill(arg1 context.Context, arg2 int64, arg3 int64, arg4 int64, arg5 database.Tx) (appdb.CharacterSkill, error) {
	fake.upsertCharacterSkillMutex.Lock()
	ret, specificReturn := fake.upsertCharacterSkillReturnsOnCall[len(fake.upsertCharacterSkillArgsForCall)]
	fake.upsertCharacterSkillArgsForCall = append(fake.upsertCharacterSkillArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
		arg4 int64
		arg5 database.Tx
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpsertCharacterSkillStub
	fakeReturns := fake.upsertCharacterSkillReturns
	fake.recordInvocation("UpsertCharacterSkill", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.upsertCharacterSkillMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertCharacterSkillCallCount() int {
	fake.upsertCharacterSkillMutex.RLock()
	defer fake.upsertCharacterSkillMutex.RUnlock()
	return len(fake.upsertCharacterSkillArgsForCall)
}

func (fake *FakeAppData) UpsertCharacterSkillCalls(stub func(context.Context, int64, int64, int64, database.Tx) (appdb.CharacterSkill, error)) {
	fake.upsertCharacterSkillMutex.Lock()
	defer fake.upsertCharacterSkillMutex.Unlock()
	fake.UpsertCharacterSkillStub = stub
}

func (fake *FakeAppData) UpsertCharacterSkillArgsForCall(i int) (context.Context, int64, int64, int64, database.Tx) {
	fake.upsertCharacterSkillMutex.RLock()
	defer fake.upsertCharacterSkillMutex.RUnlock()
	argsForCall := fake.upsertCharacterSkillArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAppData) UpsertCharacterSkillReturns(result1 appdb.CharacterSkill, result2 error) {
	fake.upsertCharacterSkillMutex.Lock()
	defer fake.upsertCharacterSkillMutex.Unlock()
	fake.UpsertCharacterSkillStub = nil
	fake.upsertCharacterSkillReturns = struct {
		result1 appdb.CharacterSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCharacterSkillReturnsOnCall(i int, result1 appdb.CharacterSkill, result2 error) {
	fake.upsertCharacterSkillMutex.Lock()
	defer fake.upsertCharacterSkillMutex.Unlock()
	fake.UpsertCharacterSkillStub = nil
	if fake.upsertCharacterSkillReturnsOnCall == nil {
		fake.upsertCharacterSkillReturnsOnCall = make(map[int]struct {
			result1 appdb.CharacterSkill
			result2 error
		})
	}
	fake.upsertCharacterSkillReturnsOnCall[i] = struct {
		result1 appdb.CharacterSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCorporation(arg1 context.Context, arg2 int64, arg3 string, arg4 string, arg5 string, arg6 int64, arg7 database.Tx) (appdb.Corporation, error) {
	fake.upsertCorporationMutex.Lock()
	ret, specificReturn := fake.upsertCorporationReturnsOnCall[len(fake.upsertCorporationArgsForCall)]
	fake.upsertCorporationArgsForCall = append(fake.upsertCorporationArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 int64
		arg7 database.Tx
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.UpsertCorporationStub
	fakeReturns := fake.upsertCorporationReturns
	fake.recordInvocation("UpsertCorporation", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.upsertCorporationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertCorporationCallCount() int {
	fake.upsertCorporationMutex.RLock()
	defer fake.upsertCorporationMutex.RUnlock()
	return len(fake.upsertCorporationArgsForCall)
}

func (fake *FakeAppData) UpsertCorporationCalls(stub func(context.Context, int64, string, string, string, int64, database.Tx) (appdb.Corporation, error)) {
	fake.upsertCorporationMutex.Lock()
	defer fake.upsertCorporationMutex.Unlock()
	fake.UpsertCorporationStub = stub
}

func (fake *FakeAppData) UpsertCorporationArgsForCall(i int) (context.Context, int64, string, string, string, int64, database.Tx) {
	fake.upsertCorporationMutex.RLock()
	defer fake.upsertCorporationMutex.RUnlock()
	argsForCall := fake.upsertCorporationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAppData) UpsertCorporationReturns(result1 appdb.Corporation, result2 error) {
	fake.upsertCorporationMutex.Lock()
	defer fake.upsertCorporationMutex.Unlock()
	fake.UpsertCorporationStub = nil
	fake.upsertCorporationReturns = struct {
		result1 appdb.Corporation
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertCorporationReturnsOnCall(i int, result1 appdb.Corporation, result2 error) {
	fake.upsertCorporationMutex.Lock()
	defer fake.upsertCorporationMutex.Unlock()
	fake.UpsertCorporationStub = nil
	if fake.upsertCorporationReturnsOnCall == nil {
		fake.upsertCorporationReturnsOnCall = make(map[int]struct {
			result1 appdb.Corporation
			result2 error
		})
	}
	fake.upsertCorporationReturnsOnCall[i] = struct {
		result1 appdb.Corporation
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertTagSkill(arg1 context.Context, arg2 int64, arg3 int64, arg4 int64, arg5 database.Tx) (appdb.TagSkill, error) {
	fake.upsertTagSkillMutex.Lock()
	ret, specificReturn := fake.upsertTagSkillReturnsOnCall[len(fake.upsertTagSkillArgsForCall)]
	fake.upsertTagSkillArgsForCall = append(fake.upsertTagSkillArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 int64
		arg4 int64
		arg5 database.Tx
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpsertTagSkillStub
	fakeReturns := fake.upsertTagSkillReturns
	fake.recordInvocation("UpsertTagSkill", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.upsertTagSkillMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertTagSkillCallCount() int {
	fake.upsertTagSkillMutex.RLock()
	defer fake.upsertTagSkillMutex.RUnlock()
	return len(fake.upsertTagSkillArgsForCall)
}

func (fake *FakeAppData) UpsertTagSkillCalls(stub func(context.Context, int64, int64, int64, database.Tx) (appdb.TagSkill, error)) {
	fake.upsertTagSkillMutex.Lock()
	defer fake.upsertTagSkillMutex.Unlock()
	fake.UpsertTagSkillStub = stub
}

func (fake *FakeAppData) UpsertTagSkillArgsForCall(i int) (context.Context, int64, int64, int64, database.Tx) {
	fake.upsertTagSkillMutex.RLock()
	defer fake.upsertTagSkillMutex.RUnlock()
	argsForCall := fake.upsertTagSkillArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeAppData) UpsertTagSkillReturns(result1 appdb.TagSkill, result2 error) {
	fake.upsertTagSkillMutex.Lock()
	defer fake.upsertTagSkillMutex.Unlock()
	fake.UpsertTagSkillStub = nil
	fake.upsertTagSkillReturns = struct {
		result1 appdb.TagSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertTagSkillReturnsOnCall(i int, result1 appdb.TagSkill, result2 error) {
	fake.upsertTagSkillMutex.Lock()
	defer fake.upsertTagSkillMutex.Unlock()
	fake.UpsertTagSkillStub = nil
	if fake.upsertTagSkillReturnsOnCall == nil {
		fake.upsertTagSkillReturnsOnCall = make(map[int]struct {
			result1 appdb.TagSkill
			result2 error
		})
	}
	fake.upsertTagSkillReturnsOnCall[i] = struct {
		result1 appdb.TagSkill
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertToken(arg1 context.Context, arg2 int64, arg3 string, arg4 string, arg5 string, arg6 time.Time, arg7 database.Tx) (appdb.Token, error) {
	fake.upsertTokenMutex.Lock()
	ret, specificReturn := fake.upsertTokenReturnsOnCall[len(fake.upsertTokenArgsForCall)]
	fake.upsertTokenArgsForCall = append(fake.upsertTokenArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Time
		arg7 database.Tx
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.UpsertTokenStub
	fakeReturns := fake.upsertTokenReturns
	fake.recordInvocation("UpsertToken", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.upsertTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAppData) UpsertTokenCallCount() int {
	fake.upsertTokenMutex.RLock()
	defer fake.upsertTokenMutex.RUnlock()
	return len(fake.upsertTokenArgsForCall)
}

func (fake *FakeAppData) UpsertTokenCalls(stub func(context.Context, int64, string, string, string, time.Time, database.Tx) (appdb.Token, error)) {
	fake.upsertTokenMutex.Lock()
	defer fake.upsertTokenMutex.Unlock()
	fake.UpsertTokenStub = stub
}

func (fake *FakeAppData) UpsertTokenArgsForCall(i int) (context.Context, int64, string, string, string, time.Time, database.Tx) {
	fake.upsertTokenMutex.RLock()
	defer fake.upsertTokenMutex.RUnlock()
	argsForCall := fake.upsertTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeAppData) UpsertTokenReturns(result1 appdb.Token, result2 error) {
	fake.upsertTokenMutex.Lock()
	defer fake.upsertTokenMutex.Unlock()
	fake.UpsertTokenStub = nil
	fake.upsertTokenReturns = struct {
		result1 appdb.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) UpsertTokenReturnsOnCall(i int, result1 appdb.Token, result2 error) {
	fake.upsertTokenMutex.Lock()
	defer fake.upsertTokenMutex.Unlock()
	fake.UpsertTokenStub = nil
	if fake.upsertTokenReturnsOnCall == nil {
		fake.upsertTokenReturnsOnCall = make(map[int]struct {
			result1 appdb.Token
			result2 error
		})
	}
	fake.upsertTokenReturnsOnCall[i] = struct {
		result1 appdb.Token
		result2 error
	}{result1, result2}
}

func (fake *FakeAppData) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteCharacterMutex.RLock()
	defer fake.deleteCharacterMutex.RUnlock()
	fake.deleteCharacterSkillsMutex.RLock()
	defer fake.deleteCharacterSkillsMutex.RUnlock()
	fake.deleteTagMutex.RLock()
	defer fake.deleteTagMutex.RUnlock()
	fake.deleteTagSkillsMutex.RLock()
	defer fake.deleteTagSkillsMutex.RUnlock()
	fake.getAllCharacterSkillsMutex.RLock()
	defer fake.getAllCharacterSkillsMutex.RUnlock()
	fake.getAllCharactersMutex.RLock()
	defer fake.getAllCharactersMutex.RUnlock()
	fake.getAllTagSkillsMutex.RLock()
	defer fake.getAllTagSkillsMutex.RUnlock()
	fake.getAllTagsMutex.RLock()
	defer fake.getAllTagsMutex.RUnlock()
	fake.getTokenForCharacterMutex.RLock()
	defer fake.getTokenForCharacterMutex.RUnlock()
	fake.insertTagMutex.RLock()
	defer fake.insertTagMutex.RUnlock()
	fake.updateTagMutex.RLock()
	defer fake.updateTagMutex.RUnlock()
	fake.upsertAllianceMutex.RLock()
	defer fake.upsertAllianceMutex.RUnlock()
	fake.upsertCharacterMutex.RLock()
	defer fake.upsertCharacterMutex.RUnlock()
	fake.upsertCharacterSkillMutex.RLock()
	defer fake.upsertCharacterSkillMutex.RUnlock()
	fake.upsertCorporationMutex.RLock()
	defer fake.upsertCorporationMutex.RUnlock()
	fake.upsertTagSkillMutex.RLock()
	defer fake.upsertTagSkillMutex.RUnlock()
	fake.upsertTokenMutex.RLock()
	defer fake.upsertTokenMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAppData) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repository.AppData = new(FakeAppData)
